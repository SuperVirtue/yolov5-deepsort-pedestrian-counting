# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'win.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import time
import warnings
from collections import deque

import cv2
import torch
import numpy as np
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QImage

from untitled import Ui_SelectCamera
from person_count import tlbr_midpoint, intersect
from utils.draw import draw_boxes
from deep_sort import build_tracker
from person_detect_yolov5 import Person_detect
from utils.datasets import letterbox



class Ui_MainWindow(QtWidgets.QMainWindow):

    def __init__(self, cfg, args):
        super().__init__()
        self.playmode = 0
        self.lines = []
        self.setupUi(self)
        self.cfg = cfg
        self.args = args
        self.current_frame = 0
        self.cap = []
        self.line_color = [(0, 0, 255), (0, 255, 0), (0, 255, 255), (255, 0, 0)]
        self.select_video_file_path = ''
        self.url = ''
        self.suspend = False
        self.select_video.clicked.connect(self.clickButtonSelectVideo)
        self.select_camera.clicked.connect(self.clickButtonSelectCamera)
        self.suspend_button.clicked.connect(self.clickButtonSuspend)
        self.continue_button.clicked.connect(self.clickButtonContinue)
        self.play_button.clicked.connect(self.clickButtonPlay)
        self.play_button.setDisabled(True)
        self.suspend_button.setDisabled(True)
        self.continue_button.setDisabled(True)
        self.video_label.setScaledContents(True)
        self.lineEdit_1.setText("900,0,900,900")
        self.lineEdit_2.setText("150,100,450,100")
        self.lineEdit_3.setText("600,450,1000,450")
        self.lineEdit_4.setText("500,100,1000,100")
        self.line_ch_1.setStyleSheet('color: red')
        self.line_ch_2.setStyleSheet('color: green')
        self.line_ch_3.setStyleSheet('color: yellow')
        self.line_ch_4.setStyleSheet('color: blue')
        use_cuda = self.args.use_cuda and torch.cuda.is_available()
        if not use_cuda:
            warnings.warn("Running in cpu mode which maybe very slow!", UserWarning)
        self.person_detect = Person_detect(self.args, self.select_video_file_path)

    def clickButtonSelectVideo(self):
        self.clearLabels()
        if self.select_video_file_path != '':
            self.select_video_file_path = ''
        if self.cap != []:
            self.cap.release()
        directory = QtWidgets.QFileDialog.getOpenFileName(self, "选取视频文件", "./data_test", "Video Files(*.mp4 *.mov)")
        self.select_video_file_path = directory[0]
        self.cap = cv2.VideoCapture(self.select_video_file_path)
        self.frames_num = self.cap.get(7)
        self.frame_height = self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
        self.frame_width = self.cap.get(cv2.CAP_PROP_FRAME_WIDTH)
        self.current_frame = 0
        self.deepsort = build_tracker(self.cfg, self.args.sort, use_cuda=self.args.use_cuda)
        ret, frame = self.cap.read()
        if ret:
            img = letterbox(frame, new_shape=640)[0]
            img = img[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416
            img = np.ascontiguousarray(img)
            bbox_xywh, cls_conf, cls_ids, xy = self.person_detect.detect(self.select_video_file_path, img, frame, self.cap)
            outputs = self.deepsort.update(bbox_xywh, cls_conf, frame)
            if len(outputs) > 0:
                bbox_tlwh = []
                bbox_xyxy = outputs[:, :4]
                identities = outputs[:, -1]
                frame = draw_boxes(frame, bbox_xyxy, identities)
                for bb_xyxy in bbox_xyxy:
                    bbox_tlwh.append(self.deepsort._xyxy_to_tlwh(bb_xyxy))
            self.current_frame = self.current_frame + 1
            self.Display_Image(frame)
        self.progress_label.setText("播放进度：{}/{}".format(self.current_frame,self.frames_num))
        self.suspend = False
        self.play_button.setDisabled(False)
        self.suspend_button.setDisabled(True)
        self.continue_button.setDisabled(True)
        if self.playmode == 0:
            self.playmode = 1

    def clickButtonSelectCamera(self):
        dialog = Ui_SelectCamera()
        dialog.show()
        def ok():
            self.url = dialog.url_lineEdit.text()
            dialog.close()
            self.play_button.setDisabled(True)
            self.suspend_button.setDisabled(False)
            self.continue_button.setDisabled(True)
            if self.playmode == 0:
                self.playmode = 2
            self.CameraPlayback()
        def cancel():
            dialog.close()
        dialog.OK_pushButton.clicked.connect(ok)
        dialog.cancel_pushButton.clicked.connect(cancel)
        dialog.exec_()

    def CameraPlayback(self):
        self.clearLabels()
        if self.select_video_file_path != '':
            self.select_video_file_path = ''
        if self.cap != []:
            self.cap.release()
        if self.url!='':
            self.cap = cv2.VideoCapture(self.url)
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)
            self.frame_height = self.cap.get(cv2.CAP_PROP_FRAME_HEIGHT)
            self.frame_width = self.cap.get(cv2.CAP_PROP_FRAME_WIDTH)
            self.deepsort = build_tracker(self.cfg, self.args.sort, use_cuda=self.args.use_cuda)
            with torch.no_grad():
                while self.cap.isOpened():
                    ret, frame = self.cap.read()
                    start_time = time.time()
                    if ret:
                        img = letterbox(frame, new_shape=640)[0]
                        img = img[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416
                        img = np.ascontiguousarray(img)
                        bbox_xywh, cls_conf, cls_ids, xy = self.person_detect.detect(self.select_video_file_path, img,
                                                                                     frame, self.cap)
                        outputs = self.deepsort.update(bbox_xywh, cls_conf, frame)
                        if len(outputs) > 0:
                            bbox_xyxy = outputs[:, :4]
                            identities = outputs[:, -1]
                            frame = draw_boxes(frame, bbox_xyxy, identities)
                        cv2.waitKey(1)
                        self.Display_Image(frame)
                        end_time = time.time()
                        self.fps_label.setText("FPS:{:.03f}".format(1 / (end_time - start_time)))
                        if self.suspend:
                            break
                    else:
                        self.cap.release()

    def Display_Image(self, image):
        if len(self.lines) != 0:
            count = 0
            for line in self.lines:
                start_point = (line[0][0],line[0][1])
                end_point = (line[1][0], line[1][1])
                cv2.line(image, start_point, end_point, self.line_color[count], 2)
                count = count + 1
        if (len(image.shape) == 3):
            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
            Q_img = QImage(image.data,
                           image.shape[1],
                           image.shape[0],
                           QImage.Format_RGB888)
        elif (len(image.shape) == 1):
            Q_img = QImage(image.data,
                           image.shape[1],
                           image.shape[0],
                           QImage.Format_Indexed8)
        else:
            Q_img = QImage(image.data,
                           image.shape[1],
                           image.shape[0],
                           QImage.Format_RGB888)
        self.video_label.setPixmap(QtGui.QPixmap(Q_img).scaled(self.video_label.width(), self.video_label.height()))

    def getLines(self):
        self.lines.clear()
        if self.line_ch_1.isChecked():
            line_str_1 = self.lineEdit_1.text()
            line_list_1 = line_str_1.split(',')
            self.lines.append([[int(line_list_1[0]),int(line_list_1[1])],[int(line_list_1[2]),int(line_list_1[3])]])
        if self.line_ch_2.isChecked():
            line_str_2 = self.lineEdit_2.text()
            line_list_2 = line_str_2.split(',')
            self.lines.append([[int(line_list_2[0]),int(line_list_2[1])],[int(line_list_2[2]),int(line_list_2[3])]])
        if self.line_ch_3.isChecked():
            line_str_3 = self.lineEdit_3.text()
            line_list_3 = line_str_3.split(',')
            self.lines.append([[int(line_list_3[0]),int(line_list_3[1])],[int(line_list_3[2]),int(line_list_3[3])]])
        if self.line_ch_4.isChecked():
            line_str_4 = self.lineEdit_4.text()
            line_list_4 = line_str_4.split(',')
            self.lines.append([[int(line_list_4[0]),int(line_list_4[1])],[int(line_list_4[2]),int(line_list_4[3])]])

    def clearLabels(self):
        self.progress_label.setText("播放进度：--/--")
        self.fps_label.setText("FPS：")
        self.label_line_1.setText("线条1：")
        self.label_line_2.setText("线条2：")
        self.label_line_3.setText("线条3：")
        self.label_line_4.setText("线条4：")

    def vectorAngle(self, midpoint, previous_midpoint, frame_center):
        s1 = (midpoint[0]-frame_center[0])**2+(midpoint[1]-frame_center[1])**2
        s2 = (previous_midpoint[0] - frame_center[0]) ** 2 + (previous_midpoint[1] - frame_center[1]) ** 2
        return s1-s2

    def clickButtonSuspend(self):
        if self.playmode == 1:
            self.suspend = True
            self.play_button.setDisabled(True)
            self.suspend_button.setDisabled(True)
            self.continue_button.setDisabled(False)
        if self.playmode == 2:
            self.suspend = True
            self.play_button.setDisabled(True)
            self.suspend_button.setDisabled(True)
            self.continue_button.setDisabled(False)

    def clickButtonContinue(self):
        if self.playmode == 1:
            # ----------------------------------------------
            paths = {}
            go_count_1 = go_count_2 = go_count_3 = go_count_4 = 0
            out_count_1 = out_count_2 = out_count_3 = out_count_4 = 0
            already_counted_1 = deque(maxlen=50)
            already_counted_2 = deque(maxlen=50)
            already_counted_3 = deque(maxlen=50)
            already_counted_4 = deque(maxlen=50)
            # ----------------------------------------------
            self.getLines()
            self.suspend = False
            self.play_button.setDisabled(True)
            self.suspend_button.setDisabled(False)
            self.continue_button.setDisabled(True)
            with torch.no_grad():
                while self.cap.isOpened():
                    ret, frame = self.cap.read()
                    if ret:
                        start_time = time.time()
                        img = letterbox(frame, new_shape=640)[0]
                        img = img[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416
                        img = np.ascontiguousarray(img)
                        bbox_xywh, cls_conf, cls_ids, xy = self.person_detect.detect(self.select_video_file_path, img,
                                                                                     frame, self.cap)
                        outputs = self.deepsort.update(bbox_xywh, cls_conf, frame)

                        # ------------------判断是否经过线条相关代码------------------------------
                        if len(self.lines) > 0:
                            frame_center = (self.frame_width / 2, self.frame_height / 2)
                            for track in outputs:
                                bbox = track[:4]
                                track_id = track[-1]
                                midpoint = tlbr_midpoint(bbox)
                                if track_id not in paths:
                                    paths[track_id] = deque(maxlen=2)
                                paths[track_id].append(midpoint)
                                previous_midpoint = paths[track_id][0]
                                lines_count = 0
                                if self.line_ch_1.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_1:
                                    lines_count = lines_count +1
                                    already_counted_1.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_1 += 1
                                    if angle < 0:
                                        go_count_1 += 1

                                if self.line_ch_2.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],self.lines[lines_count][1]) and track_id not in already_counted_2:
                                    lines_count = lines_count + 1
                                    already_counted_2.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_2 += 1
                                    if angle < 0:
                                        go_count_2 += 1

                                if self.line_ch_3.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_3:
                                    lines_count = lines_count + 1
                                    already_counted_3.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_3 += 1
                                    if angle < 0:
                                        go_count_3 += 1
                                if self.line_ch_4.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_4:
                                    already_counted_4.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_4 += 1
                                    if angle < 0:
                                        go_count_4 += 1

                                if len(paths) > 50:
                                    del paths[list(paths)[0]]
                            if self.line_ch_1.isChecked():
                                self.label_line_1.setText("线条1：{}人进入区域，{}人离开区域".format(go_count_1, out_count_1))
                            if self.line_ch_2.isChecked():
                                self.label_line_2.setText("线条2：{}人进入区域，{}人离开区域".format(go_count_2, out_count_2))
                            if self.line_ch_3.isChecked():
                                self.label_line_3.setText("线条3：{}人进入区域，{}人离开区域".format(go_count_3, out_count_3))
                            if self.line_ch_4.isChecked():
                                self.label_line_4.setText("线条4：{}人进入区域，{}人离开区域".format(go_count_4, out_count_4))
                        # ------------------判断是否经过线条相关代码------------------------------

                        if len(outputs) > 0:
                            bbox_xyxy = outputs[:, :4]
                            identities = outputs[:, -1]
                            frame = draw_boxes(frame, bbox_xyxy, identities)
                        cv2.waitKey(1)
                        self.current_frame = self.current_frame + 1
                        self.Display_Image(frame)
                        end_time = time.time()
                        self.progress_label.setText("播放进度：{}/{}".format(self.current_frame, self.frames_num))
                        self.fps_label.setText("FPS:{:.03f}".format(1 / (end_time - start_time)))
                        if self.suspend:
                            break
                    else:
                        self.cap.release()
        if self.playmode == 2:
            # ----------------------------------------------
            paths = {}
            go_count_1 = go_count_2 = go_count_3 = go_count_4 = 0
            out_count_1 = out_count_2 = out_count_3 = out_count_4 = 0
            already_counted_1 = deque(maxlen=50)
            already_counted_2 = deque(maxlen=50)
            already_counted_3 = deque(maxlen=50)
            already_counted_4 = deque(maxlen=50)
            # ----------------------------------------------
            self.getLines()
            self.suspend = False
            self.play_button.setDisabled(True)
            self.suspend_button.setDisabled(False)
            self.continue_button.setDisabled(True)
            with torch.no_grad():
                while self.cap.isOpened():
                    ret, frame = self.cap.read()
                    start_time = time.time()
                    if ret:
                        img = letterbox(frame, new_shape=640)[0]
                        img = img[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416
                        img = np.ascontiguousarray(img)
                        bbox_xywh, cls_conf, cls_ids, xy = self.person_detect.detect(self.select_video_file_path, img,
                                                                                     frame, self.cap)
                        outputs = self.deepsort.update(bbox_xywh, cls_conf, frame)
                        # ------------------判断是否经过线条相关代码------------------------------
                        if len(self.lines) > 0:
                            frame_center = (self.frame_width / 2, self.frame_height / 2)
                            for track in outputs:
                                bbox = track[:4]
                                track_id = track[-1]
                                midpoint = tlbr_midpoint(bbox)
                                if track_id not in paths:
                                    paths[track_id] = deque(maxlen=2)
                                paths[track_id].append(midpoint)
                                previous_midpoint = paths[track_id][0]
                                lines_count = 0
                                if self.line_ch_1.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_1:
                                    lines_count = lines_count+1
                                    already_counted_1.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_1 += 1
                                    if angle < 0:
                                        go_count_1 += 1

                                if self.line_ch_2.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0], self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_2:
                                    lines_count = lines_count+1
                                    already_counted_2.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_2 += 1
                                    if angle < 0:
                                        go_count_2 += 1

                                if self.line_ch_3.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_3:
                                    lines_count = lines_count+1
                                    already_counted_3.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_3 += 1
                                    if angle < 0:
                                        go_count_3 += 1

                                if self.line_ch_4.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_4:
                                    already_counted_4.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_4 += 1
                                    if angle < 0:
                                        go_count_4 += 1

                                if len(paths) > 50:
                                    del paths[list(paths)[0]]
                            if self.line_ch_1.isChecked():
                                self.label_line_1.setText("线条1：{}人进入区域，{}人离开区域".format(go_count_1, out_count_1))
                            if self.line_ch_2.isChecked():
                                self.label_line_2.setText("线条2：{}人进入区域，{}人离开区域".format(go_count_2, out_count_2))
                            if self.line_ch_3.isChecked():
                                self.label_line_3.setText("线条3：{}人进入区域，{}人离开区域".format(go_count_3, out_count_3))
                            if self.line_ch_4.isChecked():
                                self.label_line_4.setText("线条4：{}人进入区域，{}人离开区域".format(go_count_4, out_count_4))
                        # ------------------判断是否经过线条相关代码------------------------------
                        if len(outputs) > 0:
                            bbox_xyxy = outputs[:, :4]
                            identities = outputs[:, -1]
                            frame = draw_boxes(frame, bbox_xyxy, identities)
                        cv2.waitKey(1)
                        self.Display_Image(frame)
                        end_time = time.time()
                        self.fps_label.setText("FPS:{:.03f}".format(1 / (end_time - start_time)))
                        if self.suspend:
                            break
                    else:
                        self.cap.release()

    def clickButtonPlay(self):
        if self.playmode == 1:
            # ----------------------------------------------
            paths = {}
            go_count_1 = go_count_2 = go_count_3 = go_count_4 = 0
            out_count_1 = out_count_2 = out_count_3 = out_count_4 = 0
            already_counted_1 = deque(maxlen=50)
            already_counted_2 = deque(maxlen=50)
            already_counted_3 = deque(maxlen=50)
            already_counted_4 = deque(maxlen=50)
            # ----------------------------------------------
            self.getLines()
            self.play_button.setDisabled(True)
            self.suspend_button.setDisabled(False)
            self.continue_button.setDisabled(True)
            with torch.no_grad():
                while self.cap.isOpened():
                    ret, frame = self.cap.read()
                    if ret:
                        start_time = time.time()
                        img = letterbox(frame, new_shape=640)[0]
                        img = img[:, :, ::-1].transpose(2, 0, 1)  # BGR to RGB, to 3x416x416
                        img = np.ascontiguousarray(img)
                        bbox_xywh, cls_conf, cls_ids, xy = self.person_detect.detect(self.select_video_file_path, img,
                                                                                     frame, self.cap)
                        outputs = self.deepsort.update(bbox_xywh, cls_conf, frame)

                        # ------------------判断是否经过线条相关代码------------------------------
                        if len(self.lines) > 0:
                            frame_center = (self.frame_width / 2, self.frame_height / 2)
                            for track in outputs:
                                bbox = track[:4]
                                track_id = track[-1]
                                midpoint = tlbr_midpoint(bbox)
                                if track_id not in paths:
                                    paths[track_id] = deque(maxlen=2)
                                paths[track_id].append(midpoint)
                                previous_midpoint = paths[track_id][0]
                                lines_count = 0
                                if self.line_ch_1.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_1:
                                    lines_count = lines_count+1
                                    already_counted_1.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_1 += 1
                                    if angle < 0:
                                        go_count_1 += 1

                                if self.line_ch_2.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_2:
                                    lines_count = lines_count+1
                                    already_counted_2.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_2 += 1
                                    if angle < 0:
                                        go_count_2 += 1

                                if self.line_ch_3.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_3:
                                    lines_count = lines_count+1
                                    already_counted_3.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_3 += 1
                                    if angle < 0:
                                        go_count_3 += 1

                                if self.line_ch_4.isChecked() and intersect(midpoint, previous_midpoint,
                                                                            self.lines[lines_count][0],
                                                                            self.lines[lines_count][
                                                                                1]) and track_id not in already_counted_4:
                                    already_counted_4.append(track_id)  # Set already counted for ID to true.
                                    angle = self.vectorAngle(midpoint, previous_midpoint, frame_center)
                                    if angle > 0:
                                        out_count_4 += 1
                                    if angle < 0:
                                        go_count_4 += 1

                                if len(paths) > 50:
                                    del paths[list(paths)[0]]
                            if self.line_ch_1.isChecked():
                                self.label_line_1.setText("线条1：{}人进入区域，{}人离开区域".format(go_count_1, out_count_1))
                            if self.line_ch_2.isChecked():
                                self.label_line_2.setText("线条2：{}人进入区域，{}人离开区域".format(go_count_2, out_count_2))
                            if self.line_ch_3.isChecked():
                                self.label_line_3.setText("线条3：{}人进入区域，{}人离开区域".format(go_count_3, out_count_3))
                            if self.line_ch_4.isChecked():
                                self.label_line_4.setText("线条4：{}人进入区域，{}人离开区域".format(go_count_4, out_count_4))
                        # ------------------判断是否经过线条相关代码------------------------------

                        if len(outputs) > 0:
                            bbox_xyxy = outputs[:, :4]
                            identities = outputs[:, -1]
                            frame = draw_boxes(frame, bbox_xyxy, identities)
                        cv2.waitKey(1)
                        self.current_frame = self.current_frame + 1
                        self.Display_Image(frame)
                        end_time = time.time()
                        self.progress_label.setText("播放进度：{}/{}".format(self.current_frame, self.frames_num))
                        self.fps_label.setText("FPS：{:.03f}".format(1 / (end_time - start_time)))
                        if self.suspend:
                            break
                    else:
                        self.cap.release()
        if self.playmode == 2:
            print("hello")

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1221, 660)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.video_label = QtWidgets.QLabel(self.centralwidget)
        self.video_label.setAutoFillBackground(False)
        self.video_label.setStyleSheet("QLabel{background-color:rgb(225, 247, 255);}")
        self.video_label.setText("")
        self.video_label.setObjectName("video_label")
        self.horizontalLayout.addWidget(self.video_label)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem)
        spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.horizontalLayout_4.addItem(spacerItem1)
        self.select_video = QtWidgets.QPushButton(self.centralwidget)
        self.select_video.setObjectName("select_video")
        self.horizontalLayout_4.addWidget(self.select_video)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem2)
        self.select_camera = QtWidgets.QPushButton(self.centralwidget)
        self.select_camera.setObjectName("select_camera")
        self.horizontalLayout_4.addWidget(self.select_camera)
        spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.horizontalLayout_4.addItem(spacerItem3)
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_4.addItem(spacerItem4)
        self.verticalLayout.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem5)
        spacerItem6 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.horizontalLayout_2.addItem(spacerItem6)
        self.play_button = QtWidgets.QPushButton(self.centralwidget)
        self.play_button.setObjectName("play_button")
        self.horizontalLayout_2.addWidget(self.play_button)
        spacerItem7 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem7)
        self.suspend_button = QtWidgets.QPushButton(self.centralwidget)
        self.suspend_button.setObjectName("suspend_button")
        self.horizontalLayout_2.addWidget(self.suspend_button)
        spacerItem8 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem8)
        self.continue_button = QtWidgets.QPushButton(self.centralwidget)
        self.continue_button.setObjectName("continue_button")
        self.horizontalLayout_2.addWidget(self.continue_button)
        spacerItem9 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.horizontalLayout_2.addItem(spacerItem9)
        spacerItem10 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem10)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.line_ch_1 = QtWidgets.QCheckBox(self.centralwidget)
        self.line_ch_1.setObjectName("line_ch_1")
        self.horizontalLayout_7.addWidget(self.line_ch_1)
        self.lineEdit_1 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_1.setObjectName("lineEdit_1")
        self.horizontalLayout_7.addWidget(self.lineEdit_1)
        self.line_ch_2 = QtWidgets.QCheckBox(self.centralwidget)
        self.line_ch_2.setObjectName("line_ch_2")
        self.horizontalLayout_7.addWidget(self.line_ch_2)
        self.lineEdit_2 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.horizontalLayout_7.addWidget(self.lineEdit_2)
        self.verticalLayout_4.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.line_ch_3 = QtWidgets.QCheckBox(self.centralwidget)
        self.line_ch_3.setObjectName("line_ch_3")
        self.horizontalLayout_8.addWidget(self.line_ch_3)
        self.lineEdit_3 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_3.setObjectName("lineEdit_3")
        self.horizontalLayout_8.addWidget(self.lineEdit_3)
        self.line_ch_4 = QtWidgets.QCheckBox(self.centralwidget)
        self.line_ch_4.setObjectName("line_ch_4")
        self.horizontalLayout_8.addWidget(self.line_ch_4)
        self.lineEdit_4 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_4.setObjectName("lineEdit_4")
        self.horizontalLayout_8.addWidget(self.lineEdit_4)
        self.verticalLayout_4.addLayout(self.horizontalLayout_8)
        self.verticalLayout.addLayout(self.verticalLayout_4)
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.progress_label = QtWidgets.QLabel(self.centralwidget)
        self.progress_label.setObjectName("progress_label")
        self.verticalLayout_5.addWidget(self.progress_label)
        self.fps_label = QtWidgets.QLabel(self.centralwidget)
        self.fps_label.setObjectName("fps_label")
        self.verticalLayout_5.addWidget(self.fps_label)
        self.label_line_1 = QtWidgets.QLabel(self.centralwidget)
        self.label_line_1.setObjectName("label_line_1")
        self.verticalLayout_5.addWidget(self.label_line_1)
        self.label_line_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_line_2.setObjectName("label_line_2")
        self.verticalLayout_5.addWidget(self.label_line_2)
        self.label_line_3 = QtWidgets.QLabel(self.centralwidget)
        self.label_line_3.setObjectName("label_line_3")
        self.verticalLayout_5.addWidget(self.label_line_3)
        self.label_line_4 = QtWidgets.QLabel(self.centralwidget)
        self.label_line_4.setObjectName("label_line_4")
        self.verticalLayout_5.addWidget(self.label_line_4)
        self.verticalLayout.addLayout(self.verticalLayout_5)
        self.verticalLayout.setStretch(0, 1)
        self.verticalLayout.setStretch(1, 1)
        self.verticalLayout.setStretch(3, 5)
        self.horizontalLayout.addLayout(self.verticalLayout)
        self.horizontalLayout.setStretch(0, 4)
        self.horizontalLayout.setStretch(1, 1)
        self.gridLayout.addLayout(self.horizontalLayout, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "行人检测"))
        self.select_video.setText(_translate("MainWindow", "选择视频"))
        self.select_camera.setText(_translate("MainWindow", "选择摄像头"))
        self.play_button.setText(_translate("MainWindow", "播放"))
        self.suspend_button.setText(_translate("MainWindow", "暂停"))
        self.continue_button.setText(_translate("MainWindow", "继续"))
        self.line_ch_1.setText(_translate("MainWindow", "线条1"))
        self.line_ch_2.setText(_translate("MainWindow", "线条2"))
        self.line_ch_3.setText(_translate("MainWindow", "线条3"))
        self.line_ch_4.setText(_translate("MainWindow", "线条4"))
        self.progress_label.setText(_translate("MainWindow", "播放进度：--/--"))
        self.fps_label.setText(_translate("MainWindow", "FPS："))
        self.label_line_1.setText(_translate("MainWindow", "线条1："))
        self.label_line_2.setText(_translate("MainWindow", "线条2："))
        self.label_line_3.setText(_translate("MainWindow", "线条3："))
        self.label_line_4.setText(_translate("MainWindow", "线条4："))
